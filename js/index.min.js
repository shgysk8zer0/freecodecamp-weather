(function () {
'use strict';

if (document.createElement('dialog') instanceof HTMLUnknownElement && !HTMLElement.prototype.hasOwnProperty('open')) {
	HTMLElement.prototype.show = function() {
		this.open = true;
	};

	HTMLElement.prototype.close = function(returnValue = null) {
		this.open = false;
		if (this.tagName === 'DIALOG') {
			this.dispatchEvent(new CustomEvent('close', {detail: returnValue}));
		}
	};

	Object.defineProperty(HTMLElement.prototype, 'open', {
		set: function(open) {
			if (open) {
				this.setAttribute('open', '');
			} else {
				this.removeAttribute('open');
				if (this.tagName === 'DIALOG') {
					this.classList.remove('modal');
					const next = this.nextElementSibling;
					if (next instanceof HTMLElement && next.matches('.backdrop')) {
						next.remove();
					}
				}
			}
		},
		get: function() {
			return this.hasAttribute('open');
		}
	});
}
if (! document.createElement('dialog').hasOwnProperty('showModal')) {
	HTMLElement.prototype.showModal = function() {
		this.open = true;
		this.classList.add('modal');
		const backdrop = document.createElement('div');
		backdrop.classList.add('backdrop');
		this.after(backdrop);
	};
}

if (! ('content' in document.createElement('template'))) {
	Object.defineProperty(HTMLUnknownElement.prototype, 'content', {
		get: function() {
			const frag = document.createDocumentFragment();
			for (let i = 0; i < this.childNodes.length; i++) {
				frag.appendChild(this.childNodes[i].cloneNode(true));
			}
			return frag;
		}
	});
}

if (! HTMLElement.prototype.hasOwnProperty('contextMenu')){
	Object.defineProperty(HTMLElement.prototype, 'contextMenu', {
		get: function() {
			if (this.hasAttribute('contextmenu')) {
				return document.getElementById(this.getAttribute('contextmenu'));
			}
		}
	});
}

if (!('Notification' in window)) {
	window.Notification = window.notifications || window.webkitNotifications || window.oNotifications || window.msNotifications || false;
}
if (!('indexedDB' in window)) {
	window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB || false;
}
if (!('hidden' in document)) {
	document.hidden = document.webkitHidden || document.msHidden || document.mozHidden || false;
}
if (!('visibilityState' in document)) {
	document.visibilityState = document.webkitVisibilityState || document.msVisibilityState || document.mozVisibilityState || 'visible';
}
if (!('fullscreenElement' in document)) {
	document.fullscreenElement = document.mozFullScreenElement || document.webkitFullscreenElement || false;
}
if (!('requestAnimationFrame' in window)) {
	window.requestAnimationFrame = window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || false;
}
if (!('exitFullscreen' in Document.prototype)) {
	Document.prototype.exitFullscreen = document.mozCancelFullScreen || document.webkitCancelFullScreen || document.msCancelFullScreen || false;
}
if (!('requestFullscreen' in HTMLElement.prototype)) {
	HTMLElement.prototype.requestFullScreen = HTMLElement.prototype.mozRequestFullScreen || HTMLElement.prototype.webkitRequestFullScreen || false;
}

const PREFIXES = [
	'',
	'moz',
	'webkit',
	'ms'
];

/*============================ esQuery Functions =======================*/
class esQuery extends Set {
	constructor(selector, parent = document) {
		if (typeof selector === 'string') {
			super(parent.querySelectorAll(selector));
			if (parent instanceof HTMLElement && parent.matches(selector)) {
				this.add(parent);
			}
		} else if (selector[Symbol.iterator] instanceof Function) {
			super(selector);
		} else if (typeof selector === 'object') {
			super([selector]);
		} else {
			super();
			throw new TypeError(`Expected a string or NodeList but got a ${typeof selector}: ${selector}.`);
		}
	}

	get found() {
		return this.size !== 0;
	}

	async text(str) {
		this.forEach(node => node.textContent = str);
		return this;
	}

	async html(html) {
		this.forEach(node => node.innerHTML = html);
		return this;
	}

	async replaceText(replacements = {}) {
		this.forEach(el => Object.keys(replacements).forEach(find => {
			el.textContent = el.textContent.replace(find, replacements[find]);
		}));
		return this;
	}

	async visible() {
		return this.css({visibility: 'visible'});
	}

	async invisible() {
		return this.css({visibility: 'hidden'});
	}

	async each(callback, thisArg = this) {
		let n = 0;
		this.forEach(el => callback.call(thisArg, el, n++));
		return this;
	}

	/**
	 * Note: This is for `HTMLDialogElement.prototype.show`, not the inverse
	 * of `hide`
	 */
	async show() {
		this.forEach(node => {
			if ('show' in node) {
				node.show();
			}
		});
		return this;
	}

	async showModal() {
		this.forEach(node => {
			if ('showModal' in node) {
				node.showModal();
			}
		});
		return this;
	}

	async close() {
		this.forEach(node => {
			if ('close' in node) {
				node.close();
			}
		});
		return this;
	}

	async animate(keyframes, opts = 400) {
		if ('animate' in Element.prototype) {
			return Promise.all(await this.map(node => {
				return new Promise((resolve, reject) => {
					const anim = node.animate(keyframes, opts);
					anim.onfinish = () => resolve(node);
					anim.oncancel = reject;
				});
			})).then(els => new esQuery(els));
		} else {
			return Promise.resolve([]);
		}
	}

	async getAnimations() {
		let anims = [];
		this.forEach(el => {
			const elAnims = el.getAnimations();
			anims = anims.concat(elAnims);
		});
		return anims;
	}

	async playAnimations(...ids) {
		let anims = await this.getAnimations();
		anims.filter(anim => ids.includes(anim.id)).forEach(anim => anim.play());
		return this;
	}

	async pauseAnimations(...ids) {
		let anims = await this.getAnimations();
		anims.filter(anim => ids.includes(anim.id)).forEach(anim => anim.pause());
		return this;
	}

	async cancelAnimations(...ids) {
		const anims = await this.getAnimations();
		anims.filter(anim => ids.includes(anim.id)).forEach(anim => anim.cancel());
		return this;
	}

	async animateFilter({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 'none',
		to         = 'none',
		id         = 'grayscale',
	} = {}) {
		return this.animate([
			{filter: `${from}`},
			{filter: `${to}`},
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterDropShadow({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = '0 0 0 black',
		to         = '0.5em 0.5em 0.5em rgba(0,0,0,0.3)',
		id         = 'drop-shadow',
	} = {}) {
		return this.animate([
			{filter: `drop-shadow(${from})`},
			{filter: `drop-shadow(${to})`},
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterGrayscale({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'grayscale',
	} = {}) {
		return this.animateFilter({
			from: `grayscale(${from})`,
			to: `grayscale(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterBlur({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = '0px',
		to         = '5px',
		id         = 'blur',
	} = {}) {
		return this.animateFilter({
			from: `blur(${from})`,
			to: `blur(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterInvert({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = '100%',
		id         = 'invert',
	} = {}) {
		return this.animateFilter({
			from: `invert(${from})`,
			to: `invert(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterHueRotate({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = '0deg',
		to         = '90deg',
		id         = 'hue-rotate',
	} = {}) {
		return this.animateFilter({
			from: `hue-rotate(${from})`,
			to: `hue-rotate(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterBrightness({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'brightness',
	} = {}) {
		return this.animateFilter({
			from: `brightness(${from})`,
			to: `brightness(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterContrast({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'contrast',
	} = {}) {
		return this.animateFilter({
			from: `contrast(${from})`,
			to: `contrast(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterSaturate({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'saturate',
	} = {}) {
		return this.animateFilter({
			from: `saturate(${from})`,
			to: `saturate(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterOpacity({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'saturate',
	} = {}) {
		return this.animateFilter({
			from: `opacity(${from})`,
			to: `opacity(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async filterSepia({
		duration   = 400,
		delay      = 0,
		fill       = 'both',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'sepia',
	} = {}) {
		return this.animateFilter({
			from: `sepia(${from})`,
			to: `sepia(${to})`,
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async fade({
		duration   = 400,
		delay      = 0,
		fill       = 'forwards',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 1,
		to         = 0,
		id         = 'fade-in',
	} = {}) {
		return this.animate([
			{opacity: from},
			{opacity: to}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async fadeIn({
		duration   = 400,
		delay      = 0,
		fill       = 'forwards',
		direction  = 'normal',
		easing     = 'linear',
		iterations = 1,
		from       = 0,
		to         = 1,
		id         = 'fade-in',
	} = {}) {
		return this.fade({
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			from,
			to,
			id,
		});
	}

	async fadeOut(opts = {}) {
		return this.fade(opts);
	}

	async scale({
		duration     = 400,
		delay        = 0,
		fill         = 'both',
		direction    = 'normal',
		easing       = 'linear',
		iterations   = 1,
		id           = 'scale',
		initialScale = 0,
		scale        = 1.5,
	} = {}) {
		return this.animate([
			{transform: `scale(${initialScale})`},
			{transform: `scale(${scale})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async grow({
		duration     = 400,
		delay        = 0,
		fill         = 'both',
		direction    = 'normal',
		easing       = 'linear',
		iterations   = 1,
		id           = 'grow',
		initialScale = 0,
		scale        = 1,
	} = {}) {
		return this.scale({
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
			scale,
			initialScale,
		});
	}

	async shrink({
		duration     = 400,
		delay        = 0,
		fill         = 'both',
		direction    = 'normal',
		easing       = 'linear',
		iterations   = 1,
		id           = 'shrink',
		initialScale = 1,
		scale        = 0,
	} = {}) {
		return this.scale({
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
			scale,
			initialScale,
		});
	}

	async rotate({
		duration        = 400,
		delay           = 0,
		fill            = 'both',
		direction       = 'normal',
		easing          = 'linear',
		iterations      = 1,
		id              = 'rotate',
		rotation        = '1turn',
		initialRotation = '0turn',
	} = {}) {
		return this.animate([
			{transform: `rotate(${initialRotation})`},
			{transform: `rotate(${rotation})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async bounce({
		duration   = 400,
		delay      = 0,
		fill       = 'none',
		direction  = 'alternate',
		easing     = 'ease-in-out',
		iterations = 1,
		id         = 'bounce',
		height     = '-50px',
	} = {}) {
		return this.animate([
			{transform: 'none'},
			{transform: `translateY(${height})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async shake({
		duration   = 400,
		delay      = 0,
		fill       = 'none',
		direction  = 'alternate',
		easing     = 'cubic-bezier(.68,-0.55,.27,1.55)',
		iterations = 6,
		id         = 'shake',
		offsetX    = '60px',
		offsetY    = '20px',
		scale      = 0.9,
	} = {}) {
		return this.animate([
			{transform: 'none'},
			{transform: `translateY(${offsetY}) translateX(-${offsetX}) scale(${scale})`},
			{transform: 'none'},
			{transform: `translateY(-${offsetY}) translateX(${offsetX}) scale(${1/scale})`},
			{transform: 'none'},
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async slideLeft({
		duration     = 400,
		delay        = 0,
		fill         = 'forwards',
		direction    = 'normal',
		easing       = 'ease-in',
		iterations   = 1,
		id           = 'slide-left',
		initial      = 0,
		distance     = '50px',
	} = {}) {
		return this.animate([
			{transform: `translateX(${initial})`},
			{transform: `translateX(-${distance})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async slideRight({
		duration     = 400,
		delay        = 0,
		fill         = 'forwards',
		direction    = 'normal',
		easing       = 'ease-in',
		iterations   = 1,
		id           = 'slide-right',
		initial      = 0,
		distance     = '50px',
	} = {}) {
		return this.animate([
			{transform: `translateX(${initial})`},
			{transform: `translateX(${distance})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async slideUp({
		duration     = 400,
		delay        = 0,
		fill         = 'forwards',
		direction    = 'normal',
		easing       = 'ease-in',
		iterations   = 1,
		id           = 'slide-up',
		initial      = 0,
		distance     = '50px',
	} = {}) {
		return this.animate([
			{transform: `translateY(${initial})`},
			{transform: `translateY(-${distance})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async slideDown({
		duration     = 400,
		delay        = 0,
		fill         = 'forwards',
		direction    = 'normal',
		easing       = 'ease-in',
		iterations   = 1,
		id           = 'slide-down',
		initial      = 0,
		distance     = '50px',
	} = {}) {
		return this.animate([
			{transform: `translateY(${initial})`},
			{transform: `translateY(${distance})`}
		], {
			delay,
			duration,
			fill,
			easing,
			direction,
			iterations,
			id,
		});
	}

	async loadHTML(href) {
		const url = new URL(href, location.origin);
		const resp = await fetch(url);

		if (resp.ok) {
			const parser = new DOMParser();
			const html = await resp.text();
			const doc = parser.parseFromString(html, 'text/html');
			this.html(doc.body.innerHTML);
			return this;
		} else {
			throw new Error(`${resp.url} [${resp.status} ${resp.statusText}]`);
		}
	}

	async some(callback) {
		return [...this].some(callback);
	}

	async every(callback) {
		return [...this].every(callback);
	}

	async find(callback) {
		return [...this].find(callback);
	}

	async findAll(callback) {
		return this.filter(callback);
	}

	async map(callback) {
		return [...this].map(callback);
	}

	async filter(callback) {
		return new esQuery([...this].filter(callback));
	}

	async addClass(...classes) {
		this.forEach(el => el.classList.add(...classes));
		return this;
	}

	async removeClass(...classes) {
		this.forEach(el => el.classList.remove(...classes));
		return this;
	}

	async hasClass(cname) {
		return this.some(el => el.classList.contains(cname));
	}

	async toggleClass(cname, force = null) {
		if (force instanceof Function) {
			this.forEach(node => node.classList.toggle(cname, force(node)));
		} else if (typeof force === 'boolean') {
			this.forEach(node => node.classList.toggle(cname, force));
		} else {
			this.forEach(node => node.classList.toggle(cname));
		}
		return this;
	}

	async replaceClass(cname1, cname2) {
		this.forEach(node => node.classList.replace(cname1, cname2));
		return this;
	}

	async pickClass(cname1, cname2, condition) {
		this.toggleClass(cname1, condition);
		this.toggleClass(cname2, ! condition);
		return this;
	}

	async remove() {
		this.forEach(el => el.remove());
		return this;
	}

	async empty(query$$1 = null) {
		if (typeof query$$1 === 'string') {
			this.forEach(node => [...node.children].forEach(child => {
				if (child.matches(query$$1)) {
					child.remove();
				}
			}));
		} else {
			this.forEach(node => [...node.children].forEach(child => child.remove()));
		}
		return this;
	}

	async hide(hidden = true) {
		this.forEach(el => el.hidden = hidden);
		return this;
	}

	async unhide(shown = true) {
		return this.hide(! shown);
	}

	async append(...nodes) {
		this.forEach(el => el.append(...nodes));
		return this;
	}

	async prepend(...nodes) {
		this.forEach(el => el.prepend(...nodes));
		return this;
	}

	async before(...nodes) {
		this.forEach(el => el.before(...nodes));
		return this;
	}

	async after(...nodes) {
		this.forEach(el => el.after(...nodes));
		return this;
	}

	async afterBegin(text) {
		this.forEach(el => el.insertAdjacentHTML('afterbegin', text));
		return this;
	}

	async afterEnd(text) {
		this.forEach(el => el.insertAdjacentHTML('afterend', text));
		return this;
	}

	async beforeBegin(text) {
		this.forEach(el => el.insertAdjacentHTML('beforebegin', text));
		return this;
	}

	async beforeEnd(text) {
		this.forEach(el => el.insertAdjacentHTML('beforeend', text));
		return this;
	}

	async hasAttribute(attr) {
		return this.some(el => el.hasAttribute(attr));
	}

	async attr(attrs = {}) {
		this.forEach(node => {
			for (const [key, value] of Object.entries(attrs)) {
				switch (typeof(value)) {
				case 'string':
				case 'number':
					node.setAttribute(key, value);
					break;
				case 'boolean':
					value ? node.setAttribute(key, '') : node.removeAttribute(key);
					break;
				default:
					node.removeAttribute(key);
				}
			}
		});
		return this;
	}

	async data(props = {}) {
		this.forEach(node => {
			for (const [key, value] of Object.entries(props)) {
				if (value === false) {
					delete node.dataset[key];
				} else if (value === true || value === null) {
					node.dataset[key] = '';
				} else {
					node.dataset[key] = typeof(value) === 'string' ? value : JSON.stringify(value);
				}
			}
		});
		return this;
	}

	async pause() {
		this.forEach(media => media.pause());
		return this;
	}

	async read() {
		read(...this);
	}

	/*==================== Listener Functions =================================*/
	async on(event, callback, ...args) {
		this.forEach(node => node.addEventListener(event, callback, ...args));
		return this;
	}

	async waitUntil(...events) {
		return Promise.race(events.map(event => new Promise(resolve => this.on(event, resolve, {once: true}))));
		//new Promise(resolve => this.on(event, resolve, {once: true}));
	}

	async once(event, callback) {
		return this.on(event, callback, {once: true});
	}

	async off(event, callback) {
		this.forEach(node => node.removeEventListener(callback));
		return this;
	}

	async ready(callback, ...args) {
		this.on('DOMContentLoaded', callback, ...args);
		if (document.readyState !== 'loading') {
			this.forEach(node => {
				callback.bind(node)(new Event('DOMContentLoaded'));
			}, false);
		}
		return this;
	}

	async networkChange(callback, ...args) {
		return this.online(callback, ...args).offline(callback, ...args);
	}

	async playing(callback) {
		this.forEach(e => e.onplay = callback);
		return this;
	}

	async paused(callback) {
		this.forEach(e => e.onpause = callback, false);
		return this;
	}

	async visibilitychange(callback, ...args) {
		this.forEach(e => {
			PREFIXES.forEach(pre => {
				e.addEventListener(`${pre}visibilitychange`, callback, ...args);
			});
		}, false);
		return this;
	}

	async click(callback, ...args) {
		return this.on('click', callback, ...args);
	}

	async dblclick(callback, ...args) {
		this.on('dblclick', callback, ...args);
	}

	async contextmenu(callback, ...args) {
		return this.on('contextmenu', callback, ...args);
	}

	async keypress(callback, ...args) {
		return this.on('keypress', callback, ...args);
	}

	async keyup(callback, ...args) {
		return this.on('keyup', callback, ...args);
	}

	async keydown(callback, ...args) {
		return this.on('keydown', ...args);
	}

	async mouseenter(callback, ...args) {
		return this.on('mouseenter', callback, ...args);
	}

	async mouseleave(callback, ...args) {
		return this.on('mouseleave', callback, ...args);
	}

	async mouseover(callback, ...args) {
		return this.on('mouseover', callback, ...args);
	}

	async mouseout(callback, ...args) {
		return this.on('mouseout', callback, ...args);
	}

	async mousemove(callback, ...args) {
		return this.on('mousemove', callback, ...args);
	}

	async mousedown(callback, ...args) {
		return this.on('mousedown', callback, ...args);
	}

	async mouseup(callback, ...args) {
		return this.on('mouseup', callback, ...args);
	}

	async input(callback, ...args) {
		return this.on('input', callback, ...args);
	}

	async change(callback, ...args) {
		return this.on('change', callback, ...args);
	}

	async submit(callback, ...args) {
		return this.on('submit', callback, ...args);
	}

	async reset(callback, ...args) {
		return this.on('reset', callback, ...args);
	}

	async invalid(callback, ...args) {
		return this.on('invalid', callback, ...args);
	}

	async select(callback, ...args) {
		return this.on('select', callback, ...args);
	}

	async focus(callback, ...args) {
		return this.on('focus', callback, ...args);
	}

	async blur(callback, ...args) {
		return this.on('blur', callback, ...args);
	}

	async resize(callback, ...args) {
		return this.on('resize', callback, ...args);
	}

	async updateready(callback, ...args) {
		return this.on('updateready', ...args);
	}

	async load(callback, ...args) {
		this.on('load', callback, ...args);
		if (document.readyState === 'complete') {
			document.dispatchEvent(new Event('load'));
		}
		return this;
	}

	async unload(callback, ...args) {
		return this.on('unload', callback, ...args);
	}

	async beforeunload(callback, ...args) {
		return this.on('beforeunload', callback, ...args);
	}

	async abort(callback, ...args) {
		return this.on('abort', callback, ...args);
	}

	async error(callback, ...args) {
		return this.on('error', callback, ...args);
	}

	async scroll(callback, ...args) {
		return this.on('scroll', ...args);
	}

	async drag(callback, ...args) {
		return this.on('drag', callback, ...args);
	}

	async offline(callback, ...args) {
		return this.on('offline', callback, ...args);
	}

	async online(callback, ...args) {
		return this.on('online', callback, ...args);
	}

	async hashchange(callback, ...args) {
		return this.on('hashchange', callback, ...args);
	}

	/*visibilitychange(callback) {
		return this.on('visibilitychange', callback);
	}*/

	async popstate(callback, ...args) {
		return this.on('popstate', callback, ...args);
	}

	async pagehide(callback, ...args) {
		return this.on('pagehide', callback, ...args);
	}

	async watch(watching, options = [], attributeFilter = []) {
		/*https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver*/
		const watcher = new MutationObserver(mutations => {
			mutations.forEach(mutation => watching[mutation.type].call(mutation));
		});
		const obs = Object.keys(watching).concat(options).reduce((watch, event) => {
			watch[event] = true;
			return watch;
		}, {attributeFilter});
		this.forEach(el => watcher.observe(el, obs));
		return this;
	}

	/**
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserver
	 */
	async intersect(callback, options = {}) {
		try {
			const observer = new IntersectionObserver(callback, options);
			this.forEach(node => observer.observe(node));
		} catch(err) {
			console.error(err);
		}
		return this;
	}

	async css(props = {}) {
		this.forEach(node => {
			Object.keys(props).forEach(prop => {
				node.style.setProperty(prop, props[prop]);
			});
		});
		return this;
	}
}

function $(selector, parent = document) {
	return new esQuery(selector, parent);
}



async function ready() {
	if (document.readyState === 'loading') {
		await waitUntil(document, 'DOMContentLoaded');
	}
}



async function waitUntil(target, event) {
	const prom = new Promise(resolve => {
		target.addEventListener(event, () => resolve(), {once: true});
	});
	await prom;
}









async function read(...nodes) {
	if (! window.hasOwnProperty('speechSynthesis')) {
		throw new Error('SpeechSynthesis not supported');
	}

	for (const node of nodes) {
		if (typeof(node) === 'string') {
			/*
			 * Work-around for Chrome issue with long utterances
			 * <https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis/speak#Browser_compatibility>
			*/
			for (const chunk of chunkText(node, 200)) {
				await new Promise((resolve, reject) => {
					const utter = new SpeechSynthesisUtterance(chunk);
					utter.addEventListener('end', resolve);
					utter.addEventListener('error', reject);
					speechSynthesis.speak(utter);
				});
			}
		} else if (node  instanceof Text) {
			node.parentElement.classList.add('reading');
			await read(node.wholeText);
			node.parentElement.classList.remove('reading');
		} else if (node instanceof Element && ! node.hidden && node.hasChildNodes()) {
			await read(...node.childNodes);
		}
	}
}

function chunkText(string, length) {
	const size = Math.ceil(string.length / length);
	const chunks = Array(size);

	for (let i = 0, offset = 0; i < size; i++, offset++) {
		chunks[i] = string.substr(offset, length);
	}
	return chunks;
}











async function getLocation(options = {}) {
	/*https://developer.mozilla.org/en-US/docs/Web/API/Geolocation.getCurrentPosition*/
	return new Promise((resolve, reject) => {
		if (!('geolocation' in navigator)) {
			reject('Your browser does not support GeoLocation');
		}
		navigator.geolocation.getCurrentPosition(resolve, reject, options);
	});
}

async function alert$1(text) {
	return await new Promise(resolve => {
		const dialog = document.createElement('dialog');
		const msg = document.createElement('div');
		const close = document.createElement('button');

		dialog.classList.add('clearfix', 'animation-speed-normal', 'animation-ease-in', 'fadeInUp');
		close.classList.add('float-right');
		msg.textContent = text;
		close.textContent = 'Ok';

		dialog.addEventListener('close', event => {
			event.target.remove();
			resolve();
		});
		close.addEventListener('click', event => event.target.closest('dialog[open]').close());
		dialog.append(msg, close);
		document.body.append(dialog);
		dialog.showModal();
	});
}

const ENDPOINT = 'https://api.openweathermap.org/data/2.5/weather/';
const key = '6be145cbc5791c9f80471ff39d8523ed';

const icons = {
	clear: {
		day: 'weather-clear',
		night: 'weather-clear-night'
	},
	'few-clouds': {
		day: 'weather-few-clouds',
		night: 'weather-few-clouds-night'
	},
	fog: {
		day: 'weather-fog',
	},
	clouds: {
		day: 'weather-overcast',
	},
	'severe-alert': {
		day: 'weather-severe-alert',
	},
	showers: {
		day: 'weather-showers'
	},
	'showers-scattered': {
		day: 'weather-showers-scattered',
	},
	snow: {
		day: 'weather-snow',
	},
	thunderstorm: {
		day: 'weather-storm',
	},
	windy: {
		day: 'weather-windy',
	},
};

class Weather {
	static async getFromLocation(key$$1, {
		enableHighAccuracy = true,
		timeout            = 1500,
		maximumAge         = 3600,
		units              = 'imperial',
	} = {}) {
		const pos = await getLocation({enableHighAccuracy, timeout, maximumAge});
		const url = new URL(ENDPOINT);
		url.searchParams.set('appid', key$$1);
		url.searchParams.set('units', units);
		url.searchParams.set('lat', pos.coords.latitude);
		url.searchParams.set('lon', pos.coords.longitude);
		const resp = await fetch(url);
		if (resp.ok) {
			return resp.json();
		} else {
			throw new Error(`${resp.url} [${resp.status} ${resp.statusText}]`);
		}
	}
}

// TODO: Remove JavaScript style & animations & create rules in core-css
/**
 * Configure Web Share API Shim with share params {url, icon, label}s
 * @param share {url, icon, label)[, {}, [...]]
 * @return Promise
 */
var webShareApi = (...shares) => {
	shares.forEach(share => share.url = new URL(share.url));
	if (! Navigator.prototype.hasOwnProperty('share')) {
		Navigator.prototype.share = ({
			text  = null,
			title = null,
			url   = null,
		} = {}) =>   new Promise((resolve, reject) => {
			const size   = 64;
			const dialog = document.createElement('dialog');
			const header = document.createElement('header');
			const close  = document.createElement('button');
			const body   = document.createElement('div');
			const msg    = document.createElement('b');
			const font   = 'Roboto, Helvetica, "Sans Seriff"';

			const styles = {
				dialog: {
					display: 'block',
					position: 'fixed',
					background: '#fefefe',
					top: '0',
					bottom: 'auto',
					left: '0',
					right: '0',
					transform: 'none',
					'border-radius': '0 0 5px 5px',
					'max-height': '500px',
				},
				header: {
					height: '47px',
					'line-height': '47px',
					color: '#232323',
					'box-shadow': 'none',
					'border-bottom': '1px solid #d5d5d5',
				},
				closeBtn: {
					float: 'right',
					'font-family': font,
					'font-weight': 'bold',
					'font-size': '16px',
					color: 'black',
					border: 'none',
					background: 'transparent',
				},
				msg: {
					'font-family': font,
					'font-size': '24px',
					display: 'block',
				},
				link: {
					display: 'inline-block',
					margin: '0.3em',
					'text-decoration': 'none',
					color: '#626262',
					'text-align': 'center',
					'font-family': font,
					'font-size': '20px',
				},
			};

			function closeDialog(event) {
				if (
					(event.type === 'click'
						&& ! event.target.matches('dialog[open],dialog[open] *')
					) || (event.type === 'keypress' && event.code === 'Escape')
				) {
					dialog.close('Share canceled');
				}
			}

			function css(el, rules) {
				Object.entries(rules).forEach(([key, value]) => {
					el.style.setProperty(key, value);
				});
			}

			function closeHandler(event) {
				if (Element.prototype.hasOwnProperty('animate')) {
					const rects = dialog.getClientRects()[0];
					const anim = dialog.animate([
						{top: 0},
						{top: `-${rects.height}px`},
					], {
						duration: 400,
						easing:   'ease-out',
						fill:     'both',
					});
					anim.onfinish = () => dialog.remove();
					anim.onerror = () => dialog.remove();
					anim.oncancel = () => dialog.remove();
				} else {
					dialog.remove();
				}

				document.removeEventListener('keypress', closeDialog);
				document.removeEventListener('click', closeDialog);
				reject(new DOMException(event.detail));
			}

			if (text === null && title === null && url === null) {
				reject(new TypeError('No known share data fields supplied. If using only new fields (other than title, text and url), you must feature-detect them first.'));
			} else if (shares.length === 0) {
				reject(new Error('No shares configured'));
			} else {
				msg.textContent = 'Share via';
				close.title     = 'Close dialog';

				shares.forEach(share => {
					const link = document.createElement('a');
					const icon = new Image(size, size);

					if (share.url.searchParams.has('url')) {
						share.url.searchParams.set('url', url);
					} else if (share.url.searchParams.has('u')) {
						share.url.searchParams.set('u', url);
					}

					if (share.url.searchParams.has('title')) {
						share.url.searchParams.set('title', title);
					} else if (share.url.searchParams.has('t')) {
						share.url.searchParams.set('t', title);
					} else if (share.url.searchParams.has('subject')) {
						share.url.searchParams.set('subject', title);
					} else if (share.url.searchParams.has('su')) {
						share.url.searchParams.set('su', title);
					}

					if (share.url.searchParams.has('text')) {
						share.url.searchParams.set('text', text);
					} else if (share.url.searchParams.has('summary')) {
						share.url.searchParams.set('summary', text);
					} else if (share.url.searchParams.has('body')) {
						share.url.searchParams.set('body', `${text}\n${url}`);
					}

					css(link, styles.link);

					link.target = '_blank';
					icon.src    = share.icon.toString();
					link.href   = share.url.toString();
					link.title  = share.label;

					link.append(icon, document.createElement('br'), share.label);
					body.append(link);

					link.addEventListener('click', () => {
						resolve();
						dialog.close();
					});
				});

				css(dialog, styles.dialog);
				css(header, styles.header);
				css(msg, styles.msg);
				css(close, styles.closeBtn);

				if (CSS.supports('width', 'fit-content')) {
					dialog.style.setProperty('width', 'fit-content');
				} else if (CSS.supports('width', '-moz-fit-content')) {
					dialog.style.setProperty('width', '-moz-fit-content');
				} else if (CSS.supports('width', '-webkit-fit-content')) {
					dialog.style.setProperty('width', '-webkit-fit-content');
				} else {
					dialog.style.setProperty('min-width', '320px');
				}

				header.append(close, msg);
				close.append('X');
				dialog.append(header);
				dialog.append(body);
				document.body.append(dialog);
				dialog.showModal();

				if (Element.prototype.hasOwnProperty('animate')) {
					const rects = dialog.getClientRects()[0];

					dialog.animate([
						{top: `-${rects.height}px`},
						{top: 0},
					], {
						duration: 400,
						easing:   'ease-out',
						fill:     'both',
					});
				}

				dialog.addEventListener('close', closeHandler, {once: true});
				document.addEventListener('keypress', closeDialog);
				document.addEventListener('click', closeDialog);
				close.addEventListener('click', () => {
					dialog.close('Share canceled');
				}, {once: true});
			}
		});
	}
};

const facebook = {
	url: new URL('https://www.facebook.com/sharer/sharer.php?u&t'),
	icon: new URL('img/logos/facebook.svg', document.baseURI),
	label: 'Facebook',
};

const twitter = {
	url: new URL('https://twitter.com/intent/tweet/?text&url'),
	icon: new URL('img/logos/twitter.svg', document.baseURI),
	label: 'Twitter',
};

const googlePlus = {
	url: new URL('https://plus.google.com/share/?url'),
	icon: new URL('img/logos/google-plus.svg', document.baseURI),
	label: 'Google+',
};

const linkedIn = {
	url: new URL('https://www.linkedin.com/shareArticle/?title&summary&url'),
	icon: new URL('img/logos/linkedin.svg', document.baseURI),
	label: 'LinkedIn',
};

const reddit = {
	url: new URL('https://www.reddit.com/submit/?url&title'),
	icon: new URL('img/logos/reddit.svg', document.baseURI),
	label: 'Reddit',
};

const gmail = {
	url: new URL('https://mail.google.com/mail/u/0/?view=cm&fs=1&tf=1&su&body'),
	icon: new URL('img/logos/gmail.svg', document.baseURI),
	label: 'Gmail',
};

const email = {
	url: new URL('mailto:?subject&body'),
	icon: new URL('img/adwaita-icons/actions/mail-send.svg', document.baseURI),
	label: 'Email',
};

webShareApi(facebook, twitter, googlePlus, linkedIn, reddit, gmail);

function isNightTime(weather) {
	return ! isDayTime(weather);
}

function isDayTime(weather) {
	const date = new Date();
	const unixTime = (date.getTime() + date.getTimezoneOffset() * 60) / 1000;
	return unixTime > weather.sys.sunrise && unixTime < weather.sys.sunset;
}

function convertTemp() {
	const temp = parseFloat(this.textContent);
	if (this.dataset.sys.toLowerCase() === 'c') {
		this.dataset.sys = 'f';
		this.textContent = (9 / 5 * temp + 32).toFixed(2);
	} else {
		this.dataset.sys = 'c';
		this.textContent = (5 / 9 * (temp - 32)).toFixed(2);
	}
}

async function updateWeather() {
	const weather = await Weather.getFromLocation(key);
	const template = document.getElementById('weather-template').content.cloneNode(true);
	const isNight = isNightTime(weather);
	const cond = weather.weather[0].main;
	const main = document.querySelector('main');
	await $(main.children).remove();

	await $('[data-prop="city"]', template).text(weather.name);
	await $('[data-prop="country"]', template).text(weather.sys.country);
	await $('[data-prop="temp"]', template).text(weather.main.temp.toFixed(2));
	await $('[data-prop="condition"]', template).text(cond);
	await $('.weather-icon', template).each(icon => {
		icon.dataset.weatherCondition = cond;
		const use = icon.querySelector('use');
		const href = new URL(use.getAttribute('xlink:href'), location.href);
		let symbol = icons[cond.replace(' ', '-').toLowerCase()] || 'severe-alert';

		href.hash = isNight && symbol.hasOwnProperty('night') ? symbol.night : symbol.day;
		use.setAttribute('xlink:href', href);
	});

	main.append(template);
	$('[data-prop="temp"]').click(convertTemp);
}

ready().then(() => {
	updateWeather().then(() => {
		$('.cursor-wait').removeClass('cursor-wait');
		$('.js-update').click(updateWeather).then($btn => $btn.attr({disabled: false}));
		setInterval(updateWeather, 60 * 30 * 1000);
	}).catch(err => {
		$('.error-message').removeClass('hidden');
		$('.cursor-wait').removeClass('cursor-wait');
		alert$1(err.message);
	});

	$('.js-share').click(event => {
		event.preventDefault();
		event.stopPropagation();
		navigator.share({
			title: document.title,
			url: location.href,
			text: document.querySelector('meta[name="description"]').content,
		}).catch(console.error);
	});
});

}());
//# sourceMappingURL=index.min.js.map
